From b075b3e983813c0961fad0b9aab249678a93ea3c Mon Sep 17 00:00:00 2001
From: xMeM <haooy@outlook.com>
Date: Sat, 26 Oct 2024 19:19:39 +0800
Subject: [PATCH 1/3] Android Vulkan wrapper

Wrap the Android Vulkan loader into ICD, using common WSI to provide X11 platform surface support.

Signed-off-by: xMeM <haooy@outlook.com>
---
 meson.build                                   |   1 +
 meson_options.txt                             |   2 +-
 src/vulkan/meson.build                        |   5 +-
 src/vulkan/wrapper/meson.build                |  87 +++++
 src/vulkan/wrapper/vk_entrypoints.py          |   1 +
 src/vulkan/wrapper/vk_extensions.py           |   1 +
 src/vulkan/wrapper/vk_wrapper_features_gen.py | 298 ++++++++++++++
 .../wrapper/vk_wrapper_trampolines_gen.py     | 222 +++++++++++
 src/vulkan/wrapper/wrapper_device.c           | 364 ++++++++++++++++++
 src/vulkan/wrapper/wrapper_instance.c         | 295 ++++++++++++++
 src/vulkan/wrapper/wrapper_physical_device.c  | 153 ++++++++
 src/vulkan/wrapper/wrapper_private.h          |  75 ++++
 src/vulkan/wsi/wsi_common.c                   |  26 +-
 src/vulkan/wsi/wsi_common.h                   |   2 +
 14 files changed, 1526 insertions(+), 6 deletions(-)
 create mode 100644 src/vulkan/wrapper/meson.build
 create mode 120000 src/vulkan/wrapper/vk_entrypoints.py
 create mode 120000 src/vulkan/wrapper/vk_extensions.py
 create mode 100644 src/vulkan/wrapper/vk_wrapper_features_gen.py
 create mode 100644 src/vulkan/wrapper/vk_wrapper_trampolines_gen.py
 create mode 100644 src/vulkan/wrapper/wrapper_device.c
 create mode 100644 src/vulkan/wrapper/wrapper_instance.c
 create mode 100644 src/vulkan/wrapper/wrapper_physical_device.c
 create mode 100644 src/vulkan/wrapper/wrapper_private.h

diff --git a/meson.build b/meson.build
index 9fb4160cf54..0e4b114a9fc 100644
--- a/meson.build
+++ b/meson.build
@@ -243,6 +243,7 @@ elif _vulkan_drivers.contains('all')
                       'nouveau']
 endif
 
+with_wrapper_vk = _vulkan_drivers.contains('wrapper')
 with_intel_vk = _vulkan_drivers.contains('intel')
 with_intel_hasvk = _vulkan_drivers.contains('intel_hasvk')
 with_amd_vk = _vulkan_drivers.contains('amd')
diff --git a/meson_options.txt b/meson_options.txt
index 382393e5097..325219090bd 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -236,7 +236,7 @@ option(
   value : ['auto'],
   choices : ['auto', 'amd', 'broadcom', 'freedreno', 'intel', 'intel_hasvk',
              'panfrost', 'swrast', 'virtio', 'imagination-experimental',
-             'microsoft-experimental', 'nouveau', 'all'],
+             'microsoft-experimental', 'nouveau', 'wrapper', 'all'],
   description : 'List of vulkan drivers to build. If this is set to auto ' +
                 'all drivers applicable to the target OS/architecture ' +
                 'will be built'
diff --git a/src/vulkan/meson.build b/src/vulkan/meson.build
index 56f35fc90fe..f54b6b444ff 100644
--- a/src/vulkan/meson.build
+++ b/src/vulkan/meson.build
@@ -62,7 +62,7 @@ if with_xlib_lease
   vulkan_wsi_deps += [dep_xlib_xrandr]
   vulkan_wsi_list += '-DVK_USE_PLATFORM_XLIB_XRANDR_EXT'
 endif
-if with_platform_android
+if with_platform_android or with_wrapper_vk
   vulkan_wsi_list += '-DVK_USE_PLATFORM_ANDROID_KHR'
 endif
 if with_platform_windows
@@ -88,3 +88,6 @@ endif
 if with_vulkan_device_select_layer
   subdir('device-select-layer')
 endif
+if with_wrapper_vk
+  subdir('wrapper')
+endif
diff --git a/src/vulkan/wrapper/meson.build b/src/vulkan/wrapper/meson.build
new file mode 100644
index 00000000000..8f6e665d0b6
--- /dev/null
+++ b/src/vulkan/wrapper/meson.build
@@ -0,0 +1,87 @@
+wrapper_icd = custom_target(
+  'wrapper_icd',
+  input: [vk_icd_gen, vk_api_xml],
+  output: 'wrapper_icd.@0@.json'.format(host_machine.cpu()),
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--api-version', '1.3',
+    '--xml', '@INPUT1@',
+    '--lib-path', join_paths(get_option('prefix'), get_option('libdir'), 'libvulkan_wrapper.so'),
+    '--out', '@OUTPUT@',
+  ],
+  build_by_default: true,
+  install_dir: with_vulkan_icd_dir,
+  install: true,
+)
+
+wrapper_entrypoints = custom_target(
+  'wrapper_entrypoints',
+  input: [vk_entrypoints_gen, vk_api_xml],
+  output: ['wrapper_entrypoints.h', 'wrapper_entrypoints.c'],
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--xml', '@INPUT1@',
+    '--proto',
+    '--weak',
+    '--beta', with_vulkan_beta.to_string(),
+    '--out-h', '@OUTPUT0@',
+    '--out-c', '@OUTPUT1@',
+    '--prefix', 'wrapper',
+  ],
+  depend_files: vk_entrypoints_gen_depend_files,
+)
+
+wrapper_trampolines_gen = files('vk_wrapper_trampolines_gen.py')
+
+wrapper_trampolines = custom_target(
+  'wrapper_trampolines',
+  input: [wrapper_trampolines_gen, vk_api_xml],
+  output: ['wrapper_trampolines.c', 'wrapper_trampolines.h'],
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--xml', '@INPUT1@',
+    '--out-c', '@OUTPUT0@',
+    '--out-h', '@OUTPUT1@',
+    '--beta', with_vulkan_beta.to_string(),
+  ],
+  depend_files: vk_dispatch_trampolines_gen_depend_files,
+)
+
+wrapper_features_gen = files('vk_wrapper_features_gen.py')
+
+wrapper_features = custom_target(
+  'vk_wrapper_features',
+  input: [wrapper_features_gen, vk_api_xml],
+  output: ['wrapper_features.c'],
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--xml', '@INPUT1@',
+    '--out-c', '@OUTPUT0@',
+    '--beta', with_vulkan_beta.to_string(),
+  ],
+  depend_files: vk_physical_device_features_gen_depend_files,
+)
+
+wrapper_files = files('wrapper_device.c', 'wrapper_instance.c', 'wrapper_physical_device.c')
+
+wrapper_deps = [
+  idep_vulkan_runtime,
+  idep_vulkan_util,
+  idep_vulkan_wsi,
+]
+
+libvulkan_wrapper = shared_library(
+  'vulkan_wrapper',
+  [wrapper_entrypoints, wrapper_trampolines, wrapper_features, wrapper_files],
+  include_directories: [
+    inc_include,
+    inc_src,
+  ],
+  dependencies: [wrapper_deps, vulkan_wsi_deps],
+  gnu_symbol_visibility: 'hidden',
+  install: true,
+)
diff --git a/src/vulkan/wrapper/vk_entrypoints.py b/src/vulkan/wrapper/vk_entrypoints.py
new file mode 120000
index 00000000000..bbc9deb820f
--- /dev/null
+++ b/src/vulkan/wrapper/vk_entrypoints.py
@@ -0,0 +1 @@
+../util/vk_entrypoints.py
\ No newline at end of file
diff --git a/src/vulkan/wrapper/vk_extensions.py b/src/vulkan/wrapper/vk_extensions.py
new file mode 120000
index 00000000000..4407eca87b3
--- /dev/null
+++ b/src/vulkan/wrapper/vk_extensions.py
@@ -0,0 +1 @@
+../util/vk_extensions.py
\ No newline at end of file
diff --git a/src/vulkan/wrapper/vk_wrapper_features_gen.py b/src/vulkan/wrapper/vk_wrapper_features_gen.py
new file mode 100644
index 00000000000..eef8d4bf85b
--- /dev/null
+++ b/src/vulkan/wrapper/vk_wrapper_features_gen.py
@@ -0,0 +1,298 @@
+COPYRIGHT=u"""
+/* Copyright Â© 2021 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+"""
+
+import argparse
+from collections import OrderedDict
+from dataclasses import dataclass
+import os
+import sys
+import typing
+import xml.etree.ElementTree as et
+
+import mako
+from mako.template import Template
+from vk_extensions import Requirements, get_all_required, filter_api
+
+def str_removeprefix(s, prefix):
+    if s.startswith(prefix):
+        return s[len(prefix):]
+    return s
+
+RENAMED_FEATURES = {
+    # See https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/17272#note_1446477 for details
+    ('BufferDeviceAddressFeaturesEXT', 'bufferDeviceAddressCaptureReplay'): 'bufferDeviceAddressCaptureReplayEXT',
+
+    ('MeshShaderFeaturesNV', 'taskShader'): 'taskShaderNV',
+    ('MeshShaderFeaturesNV', 'meshShader'): 'meshShaderNV',
+
+    ('CooperativeMatrixFeaturesNV', 'cooperativeMatrix'): 'cooperativeMatrixNV',
+    ('CooperativeMatrixFeaturesNV', 'cooperativeMatrixRobustBufferAccess'): 'cooperativeMatrixRobustBufferAccessNV',
+
+    ('DeviceGeneratedCommandsFeaturesNV', 'deviceGeneratedCommands'): 'deviceGeneratedCommandsNV',
+}
+
+KNOWN_ALIASES = [
+    (['Vulkan11Features', '16BitStorageFeatures'], ['storageBuffer16BitAccess', 'uniformAndStorageBuffer16BitAccess', 'storagePushConstant16', 'storageInputOutput16']),
+    (['Vulkan11Features', 'MultiviewFeatures'], ['multiview', 'multiviewGeometryShader', 'multiviewTessellationShader']),
+    (['Vulkan11Features', 'VariablePointersFeatures'], ['variablePointersStorageBuffer', 'variablePointers']),
+    (['Vulkan11Features', 'ProtectedMemoryFeatures'], ['protectedMemory']),
+    (['Vulkan11Features', 'SamplerYcbcrConversionFeatures'], ['samplerYcbcrConversion']),
+    (['Vulkan11Features', 'ShaderDrawParametersFeatures'], ['shaderDrawParameters']),
+
+    (['Vulkan12Features', '8BitStorageFeatures'], ['storageBuffer8BitAccess', 'uniformAndStorageBuffer8BitAccess', 'storagePushConstant8']),
+    (['Vulkan12Features', 'ShaderAtomicInt64Features'], ['shaderBufferInt64Atomics', 'shaderSharedInt64Atomics']),
+    (['Vulkan12Features', 'ShaderFloat16Int8Features'], ['shaderFloat16', 'shaderInt8']),
+    (
+        ['Vulkan12Features', 'DescriptorIndexingFeatures'],
+        [
+            'shaderInputAttachmentArrayDynamicIndexing',
+            'shaderUniformTexelBufferArrayDynamicIndexing',
+            'shaderStorageTexelBufferArrayDynamicIndexing',
+            'shaderUniformBufferArrayNonUniformIndexing',
+            'shaderSampledImageArrayNonUniformIndexing',
+            'shaderStorageBufferArrayNonUniformIndexing',
+            'shaderStorageImageArrayNonUniformIndexing',
+            'shaderInputAttachmentArrayNonUniformIndexing',
+            'shaderUniformTexelBufferArrayNonUniformIndexing',
+            'shaderStorageTexelBufferArrayNonUniformIndexing',
+            'descriptorBindingUniformBufferUpdateAfterBind',
+            'descriptorBindingSampledImageUpdateAfterBind',
+            'descriptorBindingStorageImageUpdateAfterBind',
+            'descriptorBindingStorageBufferUpdateAfterBind',
+            'descriptorBindingUniformTexelBufferUpdateAfterBind',
+            'descriptorBindingStorageTexelBufferUpdateAfterBind',
+            'descriptorBindingUpdateUnusedWhilePending',
+            'descriptorBindingPartiallyBound',
+            'descriptorBindingVariableDescriptorCount',
+            'runtimeDescriptorArray',
+        ],
+    ),
+    (['Vulkan12Features', 'ScalarBlockLayoutFeatures'], ['scalarBlockLayout']),
+    (['Vulkan12Features', 'ImagelessFramebufferFeatures'], ['imagelessFramebuffer']),
+    (['Vulkan12Features', 'UniformBufferStandardLayoutFeatures'], ['uniformBufferStandardLayout']),
+    (['Vulkan12Features', 'ShaderSubgroupExtendedTypesFeatures'], ['shaderSubgroupExtendedTypes']),
+    (['Vulkan12Features', 'SeparateDepthStencilLayoutsFeatures'], ['separateDepthStencilLayouts']),
+    (['Vulkan12Features', 'HostQueryResetFeatures'], ['hostQueryReset']),
+    (['Vulkan12Features', 'TimelineSemaphoreFeatures'], ['timelineSemaphore']),
+    (['Vulkan12Features', 'BufferDeviceAddressFeatures', 'BufferDeviceAddressFeaturesEXT'], ['bufferDeviceAddress', 'bufferDeviceAddressMultiDevice']),
+    (['Vulkan12Features', 'BufferDeviceAddressFeatures'], ['bufferDeviceAddressCaptureReplay']),
+    (['Vulkan12Features', 'VulkanMemoryModelFeatures'], ['vulkanMemoryModel', 'vulkanMemoryModelDeviceScope', 'vulkanMemoryModelAvailabilityVisibilityChains']),
+
+    (['Vulkan13Features', 'ImageRobustnessFeatures'], ['robustImageAccess']),
+    (['Vulkan13Features', 'InlineUniformBlockFeatures'], ['inlineUniformBlock', 'descriptorBindingInlineUniformBlockUpdateAfterBind']),
+    (['Vulkan13Features', 'PipelineCreationCacheControlFeatures'], ['pipelineCreationCacheControl']),
+    (['Vulkan13Features', 'PrivateDataFeatures'], ['privateData']),
+    (['Vulkan13Features', 'ShaderDemoteToHelperInvocationFeatures'], ['shaderDemoteToHelperInvocation']),
+    (['Vulkan13Features', 'ShaderTerminateInvocationFeatures'], ['shaderTerminateInvocation']),
+    (['Vulkan13Features', 'SubgroupSizeControlFeatures'], ['subgroupSizeControl', 'computeFullSubgroups']),
+    (['Vulkan13Features', 'Synchronization2Features'], ['synchronization2']),
+    (['Vulkan13Features', 'TextureCompressionASTCHDRFeatures'], ['textureCompressionASTC_HDR']),
+    (['Vulkan13Features', 'ZeroInitializeWorkgroupMemoryFeatures'], ['shaderZeroInitializeWorkgroupMemory']),
+    (['Vulkan13Features', 'DynamicRenderingFeatures'], ['dynamicRendering']),
+    (['Vulkan13Features', 'ShaderIntegerDotProductFeatures'], ['shaderIntegerDotProduct']),
+    (['Vulkan13Features', 'Maintenance4Features'], ['maintenance4']),
+]
+
+for (feature_structs, features) in KNOWN_ALIASES:
+    for flag in features:
+        for f in feature_structs:
+            rename = (f, flag)
+            assert rename not in RENAMED_FEATURES, f"{rename} already exists in RENAMED_FEATURES"
+            RENAMED_FEATURES[rename] = flag
+
+def get_renamed_feature(c_type, feature):
+    return RENAMED_FEATURES.get((str_removeprefix(c_type, 'VkPhysicalDevice'), feature), feature)
+
+@dataclass
+class FeatureStruct:
+    reqs: Requirements
+    c_type: str
+    s_type: str
+    features: typing.List[str]
+
+TEMPLATE_C = Template(COPYRIGHT + """
+/* This file generated from ${filename}, don't edit directly. */
+
+#include "wrapper_private.h"
+#include "vk_physical_device_features.h"
+#include "vk_util.h"
+
+void
+wrapper_setup_device_features(struct wrapper_physical_device *physical_device)
+{
+   VkPhysicalDevice vk_physical_device = physical_device->dispatch_handle;
+
+   /* Query the device what kind of features are supported. */
+   VkPhysicalDeviceFeatures2 supported_features2 = {
+      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
+   };
+
+% for f in feature_structs:
+   ${f.c_type} supported_${f.c_type} = {
+      .sType = ${f.s_type},
+      .pNext = NULL,
+   };
+   __vk_append_struct(&supported_features2, &supported_${f.c_type});
+% endfor
+
+   physical_device->dispatch_table.GetPhysicalDeviceFeatures2(
+      vk_physical_device, &supported_features2);
+
+   vk_set_physical_device_features(&physical_device->vk.supported_features,
+                                   &supported_features2);
+}
+""")
+
+def get_pdev_features(doc):
+    _type = doc.find(".types/type[@name='VkPhysicalDeviceFeatures']")
+    if _type is not None:
+        flags = []
+        for p in _type.findall('./member'):
+            assert p.find('./type').text == 'VkBool32'
+            flags.append(p.find('./name').text)
+        return flags
+    return None
+
+def filter_api(elem, api):
+    if 'api' not in elem.attrib:
+        return True
+
+    return api in elem.attrib['api'].split(',')
+
+def get_feature_structs(doc, api, beta):
+    feature_structs = OrderedDict()
+
+    required = get_all_required(doc, 'type', api, beta)
+
+    # parse all struct types where structextends VkPhysicalDeviceFeatures2
+    for _type in doc.findall('./types/type[@category="struct"]'):
+        if _type.attrib.get('structextends') != 'VkPhysicalDeviceFeatures2,VkDeviceCreateInfo':
+            continue
+        if _type.attrib['name'] not in required:
+            continue
+
+        reqs = required[_type.attrib['name']]
+        # Skip extensions with a define for now
+        guard = reqs.guard
+        if guard is not None and (guard != "VK_ENABLE_BETA_EXTENSIONS" or beta != "true"):
+            continue
+
+        # find Vulkan structure type
+        for elem in _type:
+            if "STRUCTURE_TYPE" in str(elem.attrib):
+                s_type = elem.attrib.get('values')
+
+        # collect a list of feature flags
+        flags = []
+
+        for p in _type.findall('./member'):
+            if not filter_api(p, api):
+                continue
+
+            m_name = p.find('./name').text
+            if m_name == 'pNext':
+                pass
+            elif m_name == 'sType':
+                s_type = p.attrib.get('values')
+            else:
+                assert p.find('./type').text == 'VkBool32'
+                flags.append(m_name)
+
+        feature_struct = FeatureStruct(reqs=reqs, c_type=_type.attrib.get('name'), s_type=s_type, features=flags)
+        feature_structs[feature_struct.c_type] = feature_struct
+
+    return feature_structs.values()
+
+def get_feature_structs_from_xml(xml_files, beta, api='vulkan'):
+    diagnostics = []
+
+    pdev_features = None
+    feature_structs = []
+
+    for filename in xml_files:
+        doc = et.parse(filename)
+        feature_structs += get_feature_structs(doc, api, beta)
+        if not pdev_features:
+            pdev_features = get_pdev_features(doc)
+
+    unused_renames = {**RENAMED_FEATURES}
+
+    features = OrderedDict()
+
+    for flag in pdev_features:
+        features[flag] = 'VkPhysicalDeviceFeatures'
+
+    for f in feature_structs:
+        for flag in f.features:
+            renamed_flag = get_renamed_feature(f.c_type, flag)
+            if renamed_flag not in features:
+                features[renamed_flag] = f.c_type
+            else:
+                a = str_removeprefix(features[renamed_flag], 'VkPhysicalDevice')
+                b = str_removeprefix(f.c_type, 'VkPhysicalDevice')
+                if (a, flag) not in RENAMED_FEATURES or (b, flag) not in RENAMED_FEATURES:
+                    diagnostics.append(f'{a} and {b} both define {flag}')
+
+            unused_renames.pop((str_removeprefix(f.c_type, 'VkPhysicalDevice'), flag), None)
+
+    for rename in unused_renames:
+        diagnostics.append(f'unused rename {rename}')
+
+    assert len(diagnostics) == 0, '\n'.join(diagnostics)
+
+    return pdev_features, feature_structs, features
+
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--out-c', required=True, help='Output C file.')
+    parser.add_argument('--beta', required=True, help='Enable beta extensions.')
+    parser.add_argument('--xml',
+                        help='Vulkan API XML file.',
+                        required=True, action='append', dest='xml_files')
+    args = parser.parse_args()
+
+    pdev_features, feature_structs, all_flags = get_feature_structs_from_xml(args.xml_files, args.beta)
+
+    environment = {
+        'filename': os.path.basename(__file__),
+        'pdev_features': pdev_features,
+        'feature_structs': feature_structs,
+        'all_flags': all_flags,
+        'get_renamed_feature': get_renamed_feature,
+    }
+
+    try:
+        with open(args.out_c, 'w', encoding='utf-8') as f:
+            f.write(TEMPLATE_C.render(**environment))
+    except Exception:
+        # In the event there's an error, this uses some helpers from mako
+        # to print a useful stack trace and prints it, then exits with
+        # status 1, if python is run with debug; otherwise it just raises
+        # the exception
+        print(mako.exceptions.text_error_template().render(), file=sys.stderr)
+        sys.exit(1)
+
+if __name__ == '__main__':
+    main()
diff --git a/src/vulkan/wrapper/vk_wrapper_trampolines_gen.py b/src/vulkan/wrapper/vk_wrapper_trampolines_gen.py
new file mode 100644
index 00000000000..f20fde16034
--- /dev/null
+++ b/src/vulkan/wrapper/vk_wrapper_trampolines_gen.py
@@ -0,0 +1,222 @@
+# coding=utf-8
+COPYRIGHT = """\
+/*
+ * Copyright 2020 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+"""
+
+import argparse
+import os
+
+from mako.template import Template
+
+# Mesa-local imports must be declared in meson variable
+# '{file_without_suffix}_depend_files'.
+from vk_entrypoints import get_entrypoints_from_xml
+
+TEMPLATE_H = Template(COPYRIGHT + """\
+/* This file generated from ${filename}, don't edit directly. */
+
+#ifndef WRAPPER_TRAMPOLINES_H
+#define WRAPPER_TRAMPOLINES_H
+
+#include "vk_dispatch_table.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct vk_physical_device_entrypoint_table wrapper_physical_device_trampolines;
+extern struct vk_device_entrypoint_table wrapper_device_trampolines;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* WRAPPER_TRAMPOLINES_H */
+""")
+
+TEMPLATE_C = Template(COPYRIGHT + """\
+/* This file generated from ${filename}, don't edit directly. */
+
+#include "wrapper_private.h"
+#include "wrapper_trampolines.h"
+
+% for e in entrypoints:
+  % if not e.is_physical_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+static VKAPI_ATTR ${e.return_type} VKAPI_CALL
+${e.prefixed_name('wrapper_tramp')}(${e.decl_params()})
+{
+    <% assert e.params[0].type == 'VkPhysicalDevice' %>
+    VK_FROM_HANDLE(wrapper_physical_device, vk_physical_device, ${e.params[0].name});
+  % if e.return_type == 'void':
+    vk_physical_device->dispatch_table.${e.name}(vk_physical_device->dispatch_handle, ${e.call_params(1)});
+  % else:
+    return vk_physical_device->dispatch_table.${e.name}(vk_physical_device->dispatch_handle, ${e.call_params(1)});
+  % endif
+}
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+
+struct vk_physical_device_entrypoint_table wrapper_physical_device_trampolines = {
+% for e in entrypoints:
+  % if not e.is_physical_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+    .${e.name} = ${e.prefixed_name('wrapper_tramp')},
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+};
+
+% for e in entrypoints:
+  % if not e.is_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+static VKAPI_ATTR ${e.return_type} VKAPI_CALL
+${e.prefixed_name('wrapper_tramp')}(${e.decl_params()})
+{
+  % if e.params[0].type == 'VkDevice':
+    VK_FROM_HANDLE(wrapper_device, vk_device, ${e.params[0].name});
+    % if e.return_type == 'void':
+      % if len(e.params) > 1:
+    vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle, ${e.call_params(1)});
+      % else:
+    vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle);
+      % endif
+    % else:
+      % if len(e.params) > 1:
+    return vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle, ${e.call_params(1)});
+      % else:
+    return vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle);
+      % endif
+    % endif
+  % elif e.params[0].type == 'VkCommandBuffer':
+    VK_FROM_HANDLE(wrapper_command_buffer, wcb, ${e.params[0].name});
+    % if e.return_type == 'void':
+      % if len(e.params) > 1:
+    wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle, ${e.call_params(1)});
+      % else:
+    wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle);
+      % endif
+    % else:
+      % if len(e.params) > 1:
+    return wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle, ${e.call_params(1)});
+      % else:
+    return wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle);
+      % endif
+    % endif
+  % elif e.params[0].type == 'VkQueue':
+    VK_FROM_HANDLE(wrapper_queue, wqueue, ${e.params[0].name});
+    % if e.return_type == 'void':
+      % if len(e.params) > 1:
+    wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle, ${e.call_params(1)});
+      % else:
+    wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle);
+      % endif
+    % else:
+      % if len(e.params) > 1:
+    return wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle, ${e.call_params(1)});
+      % else:
+    return wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle);
+      % endif
+    % endif
+  % else:
+    assert(!"Unhandled device child trampoline case: ${e.params[0].type}");
+  % endif
+}
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+
+struct vk_device_entrypoint_table wrapper_device_trampolines = {
+% for e in entrypoints:
+  % if not e.is_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+    .${e.name} = ${e.prefixed_name('wrapper_tramp')},
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+};
+""")
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--out-c', help='Output C file.')
+    parser.add_argument('--out-h', help='Output H file.')
+    parser.add_argument('--beta', required=True, help='Enable beta extensions.')
+    parser.add_argument('--xml',
+                        help='Vulkan API XML file.',
+                        required=True,
+                        action='append',
+                        dest='xml_files')
+    args = parser.parse_args()
+
+    entrypoints = get_entrypoints_from_xml(args.xml_files, args.beta)
+
+    # For outputting entrypoints.h we generate a anv_EntryPoint() prototype
+    # per entry point.
+    try:
+        if args.out_h:
+            with open(args.out_h, 'w', encoding='utf-8') as f:
+                f.write(TEMPLATE_H.render(entrypoints=entrypoints,
+                                          filename=os.path.basename(__file__)))
+        if args.out_c:
+            with open(args.out_c, 'w', encoding='utf-8') as f:
+                f.write(TEMPLATE_C.render(entrypoints=entrypoints,
+                                          filename=os.path.basename(__file__)))
+    except Exception:
+        # In the event there's an error, this imports some helpers from mako
+        # to print a useful stack trace and prints it, then exits with
+        # status 1, if python is run with debug; otherwise it just raises
+        # the exception
+        if __debug__:
+            import sys
+            from mako import exceptions
+            sys.stderr.write(exceptions.text_error_template().render() + '\n')
+            sys.exit(1)
+        raise
+
+
+if __name__ == '__main__':
+    main()
diff --git a/src/vulkan/wrapper/wrapper_device.c b/src/vulkan/wrapper/wrapper_device.c
new file mode 100644
index 00000000000..19218673dcc
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_device.c
@@ -0,0 +1,364 @@
+#include "wrapper_private.h"
+#include "wrapper_entrypoints.h"
+#include "wrapper_trampolines.h"
+#include "vk_alloc.h"
+#include "vk_common_entrypoints.h"
+#include "vk_device.h"
+#include "vk_dispatch_table.h"
+#include "vk_extensions.h"
+#include "vk_queue.h"
+#include "util/list.h"
+
+const struct vk_device_extension_table wrapper_device_extensions = {
+   .KHR_swapchain = true,
+   .EXT_swapchain_maintenance1 = true,
+   .KHR_swapchain_mutable_format = true,
+#ifdef VK_USE_PLATFORM_DISPLAY_KHR
+   .EXT_display_control = true,
+#endif
+   .KHR_present_id = true,
+   .KHR_present_wait = true,
+   .KHR_incremental_present = true,
+};
+
+const struct vk_device_extension_table wrapper_filter_extensions = {
+   .EXT_hdr_metadata = true,
+   .GOOGLE_display_timing = true,
+   .KHR_shared_presentable_image = true,
+   .EXT_image_compression_control_swapchain = true,
+};
+
+static inline void
+set_swapchain_required_extensions(const struct vk_device *device,
+                                  uint32_t *enable_extension_count,
+                                  const char **enable_extensions) {
+   uint32_t count = *enable_extension_count;
+#define REQUIRED_EXTENSION(name) \
+   assert (count < VK_DEVICE_EXTENSION_COUNT); \
+   if (!device->enabled_extensions.name && \
+       device->physical->supported_extensions.name) { \
+      enable_extensions[count++] = "VK_" #name; \
+   }
+   REQUIRED_EXTENSION(KHR_external_fence);
+   REQUIRED_EXTENSION(KHR_external_semaphore);
+   REQUIRED_EXTENSION(KHR_external_memory);
+   REQUIRED_EXTENSION(KHR_external_fence_fd);
+   REQUIRED_EXTENSION(KHR_external_semaphore_fd);
+   REQUIRED_EXTENSION(KHR_external_memory_fd);
+   REQUIRED_EXTENSION(KHR_dedicated_allocation);
+   REQUIRED_EXTENSION(EXT_queue_family_foreign);
+   REQUIRED_EXTENSION(KHR_maintenance1)
+   REQUIRED_EXTENSION(KHR_maintenance2)
+   REQUIRED_EXTENSION(KHR_image_format_list)
+   REQUIRED_EXTENSION(KHR_timeline_semaphore);
+   REQUIRED_EXTENSION(EXT_external_memory_host);
+   REQUIRED_EXTENSION(EXT_external_memory_dma_buf);
+   REQUIRED_EXTENSION(EXT_image_drm_format_modifier);
+   REQUIRED_EXTENSION(ANDROID_external_memory_android_hardware_buffer);
+#undef REQUIRED_EXTENSION
+   *enable_extension_count = count;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_CreateDevice(VkPhysicalDevice physicalDevice,
+                     const VkDeviceCreateInfo* pCreateInfo,
+                     const VkAllocationCallbacks* pAllocator,
+                     VkDevice* pDevice)
+{
+   VK_FROM_HANDLE(wrapper_physical_device, physical_device, physicalDevice);
+   const char *wrapper_enable_extensions[VK_DEVICE_EXTENSION_COUNT];
+   uint32_t wrapper_enable_extension_count = 0;
+   VkDeviceCreateInfo wrapper_create_info = *pCreateInfo;
+   struct vk_device_dispatch_table dispatch_table;
+   struct wrapper_device *device;
+   VkResult result;
+
+   device = vk_zalloc2(&physical_device->instance->vk.alloc, pAllocator,
+                       sizeof(*device), 8, VK_SYSTEM_ALLOCATION_SCOPE_DEVICE);
+
+   if (!device)
+      return vk_error(NULL, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   vk_device_dispatch_table_from_entrypoints(
+      &dispatch_table, &wrapper_device_entrypoints, true);
+   vk_device_dispatch_table_from_entrypoints(
+      &dispatch_table, &wsi_device_entrypoints, false);
+   vk_device_dispatch_table_from_entrypoints(
+      &dispatch_table, &wrapper_device_trampolines, false);
+
+   result = vk_device_init(&device->vk, &physical_device->vk,
+                           &dispatch_table, pCreateInfo, pAllocator);
+
+   if (result != VK_SUCCESS) {
+      vk_free2(&device->vk.alloc, pAllocator, device);
+      return vk_error(physical_device, result);
+   }
+
+   for (int idx = 0; idx < VK_DEVICE_EXTENSION_COUNT; idx++) {
+      if (!device->vk.enabled_extensions.extensions[idx])
+         continue;
+
+      if (wrapper_device_extensions.extensions[idx])
+         continue;
+
+      if (wrapper_filter_extensions.extensions[idx])
+         continue;
+
+      wrapper_enable_extensions[wrapper_enable_extension_count++] =
+         vk_device_extensions[idx].extensionName;
+   }
+
+   if (device->vk.enabled_extensions.KHR_swapchain) {
+      set_swapchain_required_extensions(&device->vk,
+                                        &wrapper_enable_extension_count,
+                                        wrapper_enable_extensions);
+   }
+
+   wrapper_create_info.enabledExtensionCount = wrapper_enable_extension_count;
+   wrapper_create_info.ppEnabledExtensionNames = wrapper_enable_extensions;
+
+   result = physical_device->dispatch_table.CreateDevice(
+      physical_device->dispatch_handle, &wrapper_create_info, pAllocator,
+      &device->dispatch_handle);
+
+   if (result != VK_SUCCESS) {
+      vk_device_finish(&device->vk);
+      vk_free2(&physical_device->instance->vk.alloc, pAllocator, device);
+      return vk_error(physical_device, result);
+   }
+
+   void *gdpa = physical_device->instance->dispatch_table.GetInstanceProcAddr(
+      physical_device->instance->dispatch_handle, "vkGetDeviceProcAddr");
+   vk_device_dispatch_table_load(&device->dispatch_table, gdpa,
+                                 device->dispatch_handle);
+
+   for (int i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
+      const VkDeviceQueueCreateInfo *create_info = &pCreateInfo->pQueueCreateInfos[i];
+      for (int j = 0; j < create_info->queueCount; j++) {
+         struct wrapper_queue *queue;
+         queue = vk_zalloc2(&device->vk.alloc, pAllocator, sizeof(*queue), 8,
+                            VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+         if (!queue)
+            goto fail_queue;
+
+         device->dispatch_table.GetDeviceQueue(device->dispatch_handle,
+                                               create_info->queueFamilyIndex,
+                                               j, &queue->dispatch_handle);;
+         queue->device = device;
+
+         result = vk_queue_init(&queue->vk, &device->vk, create_info, j);
+         if (result != VK_SUCCESS) {
+            vk_free2(&device->vk.alloc, pAllocator, queue);
+            goto fail_queue;
+         }
+      }
+   }
+   list_inithead(&device->command_buffers);
+
+   *pDevice = wrapper_device_to_handle(device);
+
+   return VK_SUCCESS;
+
+fail_queue:
+   list_for_each_entry_safe(struct vk_queue, queue, &device->vk.queues, link) {
+      vk_queue_finish(queue);
+      vk_free2(&device->vk.alloc, pAllocator, queue);
+   }
+   device->dispatch_table.DestroyDevice(device->dispatch_handle, pAllocator);
+   vk_device_finish(&device->vk);
+   vk_free2(&physical_device->instance->vk.alloc, pAllocator, device);
+   return vk_error(physical_device, VK_ERROR_OUT_OF_HOST_MEMORY);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex,
+                       uint32_t queueIndex, VkQueue* pQueue) {
+   vk_common_GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
+                        VkQueue* pQueue) {
+   vk_common_GetDeviceQueue2(device, pQueueInfo, pQueue);
+}
+
+VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+wrapper_GetDeviceProcAddr(VkDevice _device, const char* pName) {
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   return vk_device_get_proc_addr(&device->vk, pName);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_QueueSubmit(VkQueue _queue, uint32_t submitCount,
+                    const VkSubmitInfo* pSubmits, VkFence fence)
+{
+   VK_FROM_HANDLE(wrapper_queue, queue, _queue);
+   VkCommandBuffer wrapper_command_buffers[submitCount][32];
+   VkSubmitInfo wrapper_submits[submitCount];
+
+   for (int i = 0; i < submitCount; i++) {
+      const VkSubmitInfo *submit_info = &pSubmits[i];
+      for (int j = 0; j < submit_info->commandBufferCount; j++) {
+         VK_FROM_HANDLE(wrapper_command_buffer, wcb,
+                        submit_info->pCommandBuffers[j]);
+         wrapper_command_buffers[i][j] = wcb->dispatch_handle;
+      }
+      wrapper_submits[i] = pSubmits[i];
+      wrapper_submits[i].pCommandBuffers = wrapper_command_buffers[i];
+   }
+   return queue->device->dispatch_table.QueueSubmit(queue->dispatch_handle,
+                                                    submitCount,
+                                                    wrapper_submits,
+                                                    fence);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_QueueSubmit2(VkQueue _queue, uint32_t submitCount,
+                     const VkSubmitInfo2* pSubmits, VkFence fence)
+{
+   VK_FROM_HANDLE(wrapper_queue, queue, _queue);
+   VkCommandBufferSubmitInfo wrapper_command_buffers[submitCount][32];
+   VkSubmitInfo2 wrapper_submits[submitCount];
+
+   for (int i = 0; i < submitCount; i++) {
+      const VkSubmitInfo2 *submit_info = &pSubmits[i];
+      for (int j = 0; j < submit_info->commandBufferInfoCount; j++) {
+         VK_FROM_HANDLE(wrapper_command_buffer, wcb,
+                        submit_info->pCommandBufferInfos[j].commandBuffer);
+         wrapper_command_buffers[i][j] = pSubmits[i].pCommandBufferInfos[j];
+         wrapper_command_buffers[i][j].commandBuffer = wcb->dispatch_handle;
+      }
+      wrapper_submits[i] = pSubmits[i];
+      wrapper_submits[i].pCommandBufferInfos = wrapper_command_buffers[i];
+   }
+   return queue->device->dispatch_table.QueueSubmit2(queue->dispatch_handle,
+                                                     submitCount,
+                                                     wrapper_submits,
+                                                     fence);
+}
+
+static VkResult
+wrapper_command_buffer_create(struct wrapper_device *device,
+                              VkCommandPool pool,
+                              VkCommandBuffer dispatch_handle,
+                              VkCommandBuffer *pCommandBuffers) {
+   struct wrapper_command_buffer *wrapper_command_buffer;
+   wrapper_command_buffer = vk_object_zalloc(&device->vk, &device->vk.alloc,
+                              sizeof(struct wrapper_command_buffer),
+                              VK_OBJECT_TYPE_COMMAND_BUFFER);
+   if (!wrapper_command_buffer)
+      return vk_error(&device->vk, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   wrapper_command_buffer->device = device;
+   wrapper_command_buffer->pool = pool;
+   wrapper_command_buffer->dispatch_handle = dispatch_handle;
+   list_add(&wrapper_command_buffer->link, &device->command_buffers);
+
+   *pCommandBuffers = wrapper_command_buffer_to_handle(wrapper_command_buffer);
+
+   return VK_SUCCESS;
+}
+
+static void
+wrapper_command_buffer_destroy(struct wrapper_device *device,
+                               struct wrapper_command_buffer *wcb) {
+   list_del(&wcb->link);
+   vk_object_free(&device->vk, NULL, wcb);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_AllocateCommandBuffers(VkDevice _device,
+                               const VkCommandBufferAllocateInfo* pAllocateInfo,
+                               VkCommandBuffer* pCommandBuffers)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   VkCommandBuffer dispatch_handles[pAllocateInfo->commandBufferCount];
+   VkResult result;
+   uint32_t i;
+   
+   result = device->dispatch_table.AllocateCommandBuffers(device->dispatch_handle,
+                                                          pAllocateInfo,
+                                                          dispatch_handles);
+   if (result != VK_SUCCESS)
+      return result;
+
+   for (i = 0; i < pAllocateInfo->commandBufferCount; i++) {
+      result = wrapper_command_buffer_create(device,
+                                             pAllocateInfo->commandPool,
+                                             dispatch_handles[i],
+                                             &pCommandBuffers[i]);
+      if (result != VK_SUCCESS)
+         break;
+   }
+
+   if (result != VK_SUCCESS) {
+      device->dispatch_table.FreeCommandBuffers(device->dispatch_handle,
+                                                pAllocateInfo->commandPool,
+                                                pAllocateInfo->commandBufferCount,
+                                                dispatch_handles);
+      for (int q = 0; q < i; q++) {
+         VK_FROM_HANDLE(wrapper_command_buffer, wcb, pCommandBuffers[q]);
+         wrapper_command_buffer_destroy(device, wcb);
+      }
+
+      for (i = 0; i < pAllocateInfo->commandBufferCount; i++)
+         pCommandBuffers[i] = VK_NULL_HANDLE;
+
+      return result;
+   }
+
+   return VK_SUCCESS;
+}
+
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_FreeCommandBuffers(VkDevice _device,
+                           VkCommandPool commandPool,
+                           uint32_t commandBufferCount,
+                           const VkCommandBuffer* pCommandBuffers)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   VkCommandBuffer dispatch_handles[commandBufferCount];
+
+   for (int i = 0; i < commandBufferCount; i++) {
+      VK_FROM_HANDLE(wrapper_command_buffer, wcb, pCommandBuffers[i]);
+      dispatch_handles[i] = wcb->dispatch_handle;
+      wrapper_command_buffer_destroy(device, wcb);
+   }
+   device->dispatch_table.FreeCommandBuffers(device->dispatch_handle,
+                                             commandPool, commandBufferCount,
+                                             dispatch_handles);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DestroyCommandPool(VkDevice _device, VkCommandPool commandPool,
+                           const VkAllocationCallbacks* pAllocator)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   list_for_each_entry_safe(struct wrapper_command_buffer, wcb,
+                            &device->command_buffers, link) {
+      if (wcb->pool == commandPool) {
+         wrapper_command_buffer_destroy(device, wcb);
+      }
+   }
+   device->dispatch_table.DestroyCommandPool(device->dispatch_handle,
+                                             commandPool, pAllocator);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DestroyDevice(VkDevice _device, const VkAllocationCallbacks* pAllocator)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   list_for_each_entry_safe(struct wrapper_command_buffer, wcb,
+                            &device->command_buffers, link) {
+      wrapper_command_buffer_destroy(device, wcb);
+   }
+   list_for_each_entry_safe(struct vk_queue, queue, &device->vk.queues, link) {
+      vk_queue_finish(queue);
+      vk_free2(&device->vk.alloc, pAllocator, queue);
+   }
+   device->dispatch_table.DestroyDevice(device->dispatch_handle, pAllocator);
+   vk_device_finish(&device->vk);
+   vk_free2(&device->vk.alloc, pAllocator, device);
+}
+
diff --git a/src/vulkan/wrapper/wrapper_instance.c b/src/vulkan/wrapper/wrapper_instance.c
new file mode 100644
index 00000000000..17f95e5c410
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_instance.c
@@ -0,0 +1,295 @@
+#include "wrapper_private.h"
+#include "wrapper_entrypoints.h"
+#include "vk_alloc.h"
+#include "vk_common_entrypoints.h"
+#include "vk_dispatch_table.h"
+#include "vk_extensions.h"
+
+const struct vk_instance_extension_table wrapper_instance_extensions = {
+   .KHR_get_surface_capabilities2 = true,
+   .EXT_surface_maintenance1 = true,
+   .KHR_surface_protected_capabilities = true,
+   .KHR_surface = true,
+   .EXT_swapchain_colorspace = true,
+#ifdef VK_USE_PLATFORM_ANDROID_KHR
+   .KHR_android_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_XCB_KHR
+   .KHR_xcb_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_XLIB_KHR
+   .KHR_xlib_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_WAYLAND_KHR
+   .KHR_wayland_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_DISPLAY_KHR
+   .KHR_display = true,
+   .KHR_get_display_properties2 = true,
+   .EXT_display_surface_counter = true,
+   .EXT_acquire_drm_display = true,
+   .EXT_direct_mode_display = true,
+#endif
+   .EXT_headless_surface = true,
+   .EXT_debug_utils = true,
+   .EXT_debug_report = true,
+};
+
+static void *vulkan_library_handle;
+static PFN_vkCreateInstance create_instance;
+static PFN_vkGetInstanceProcAddr get_instance_proc_addr;
+static PFN_vkEnumerateInstanceVersion enumerate_instance_version;
+static PFN_vkEnumerateInstanceExtensionProperties enumerate_instance_extension_properties;
+static struct vk_instance_extension_table *supported_instance_extensions;
+
+#ifdef __LP64__
+#define DEFAULT_VULKAN_PATH "/system/lib64/libvulkan.so"
+#else
+#define DEFAULT_VULKAN_PATH "/system/lib/libvulkan.so"
+#endif
+
+static bool vulkan_library_init()
+{
+   if (vulkan_library_handle)
+      return true;
+
+   const char *env = getenv("WRAPPER_VULKAN_PATH");
+   vulkan_library_handle = dlopen(env ? env : DEFAULT_VULKAN_PATH,
+                                  RTLD_LOCAL | RTLD_NOW);
+
+   if (vulkan_library_handle) {
+      create_instance = dlsym(vulkan_library_handle, "vkCreateInstance");
+      get_instance_proc_addr = dlsym(vulkan_library_handle,
+                                     "vkGetInstanceProcAddr");
+      enumerate_instance_version = dlsym(vulkan_library_handle,
+                                         "vkEnumerateInstanceVersion");
+      enumerate_instance_extension_properties =
+         dlsym(vulkan_library_handle, "vkEnumerateInstanceExtensionProperties");
+   }
+   else {
+      fprintf(stderr, "%s", dlerror());
+   }
+
+   return vulkan_library_handle ? true : false;
+}
+
+static VkResult wrapper_vulkan_init()
+{
+   VkExtensionProperties props[VK_INSTANCE_EXTENSION_COUNT];
+   uint32_t prop_count = VK_INSTANCE_EXTENSION_COUNT;
+   VkResult result;
+
+   if (supported_instance_extensions)
+      return VK_SUCCESS;
+
+   if (!vulkan_library_init())
+      return VK_ERROR_INCOMPATIBLE_DRIVER;
+
+   result = enumerate_instance_extension_properties(NULL, &prop_count, props);
+   if (result != VK_SUCCESS)
+      return result;
+
+   supported_instance_extensions = malloc(sizeof(*supported_instance_extensions));
+   if (!supported_instance_extensions)
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+   *supported_instance_extensions = wrapper_instance_extensions;
+
+   for(int i = 0; i < prop_count; i++) {
+      int idx;
+      for (idx = 0; idx < VK_INSTANCE_EXTENSION_COUNT; idx++) {
+         if (strcmp(vk_instance_extensions[idx].extensionName,
+                    props[i].extensionName) == 0)
+            break;
+      }
+
+      if (idx >= VK_INSTANCE_EXTENSION_COUNT)
+         continue;
+
+      supported_instance_extensions->extensions[idx] = true;
+   }
+
+   return VK_SUCCESS;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_EnumerateInstanceVersion(uint32_t* pApiVersion)
+{
+
+   if (!vulkan_library_init())
+      return vk_error(NULL, VK_ERROR_INCOMPATIBLE_DRIVER);
+
+   return enumerate_instance_version(pApiVersion);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_EnumerateInstanceExtensionProperties(const char* pLayerName,
+                                             uint32_t* pPropertyCount,
+                                             VkExtensionProperties* pProperties)
+{
+   VkResult result;
+
+   result = wrapper_vulkan_init();
+   if (result != VK_SUCCESS)
+      return vk_error(NULL, result);
+
+   return vk_enumerate_instance_extension_properties(supported_instance_extensions,
+                                                     pPropertyCount,
+                                                     pProperties);
+}
+
+static inline void
+set_wrapper_required_extensions(const struct vk_instance *instance,
+                                uint32_t *enable_extension_count,
+                                const char **enable_extensions)
+{
+   uint32_t count = *enable_extension_count;
+#define REQUIRED_EXTENSION(name) \
+   assert (count < VK_INSTANCE_EXTENSION_COUNT); \
+   if (!instance->enabled_extensions.name && \
+       supported_instance_extensions->name) { \
+      enable_extensions[count++] = "VK_" #name; \
+   }
+   REQUIRED_EXTENSION(KHR_get_physical_device_properties2);
+   REQUIRED_EXTENSION(KHR_external_fence_capabilities);
+   REQUIRED_EXTENSION(KHR_external_memory_capabilities);
+   REQUIRED_EXTENSION(KHR_external_semaphore_capabilities);
+#undef REQUIRED_EXTENSION
+   *enable_extension_count = count;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_CreateInstance(const VkInstanceCreateInfo *pCreateInfo,
+                       const VkAllocationCallbacks *pAllocator,
+                       VkInstance *pInstance)
+{
+   const char *wrapper_enable_extensions[VK_INSTANCE_EXTENSION_COUNT];
+   uint32_t wrapper_enable_extension_count = 0;
+   VkInstanceCreateInfo wrapper_create_info = *pCreateInfo;
+   struct vk_instance_dispatch_table dispatch_table;
+   struct wrapper_instance *instance;
+   VkResult result;
+
+   result = wrapper_vulkan_init();
+   if (result != VK_SUCCESS)
+      return vk_error(NULL, result);
+
+   instance = vk_zalloc2(vk_default_allocator(), pAllocator, sizeof(*instance),
+                         8, VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE);
+   if (!instance)
+      return vk_error(NULL, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   vk_instance_dispatch_table_from_entrypoints(
+      &dispatch_table, &wrapper_instance_entrypoints, true);
+   vk_instance_dispatch_table_from_entrypoints(
+      &dispatch_table, &wsi_instance_entrypoints, false);
+
+   result = vk_instance_init(&instance->vk, supported_instance_extensions,
+                             &dispatch_table, pCreateInfo,
+                             pAllocator ? pAllocator : vk_default_allocator());
+
+   if (result != VK_SUCCESS) {
+      vk_free2(vk_default_allocator(), pAllocator, instance);
+      return vk_error(NULL, result);
+   }
+
+   instance->vk.physical_devices.enumerate = enumerate_physical_device;
+   instance->vk.physical_devices.destroy = destroy_physical_device;
+
+   for (int idx = 0; idx < pCreateInfo->enabledExtensionCount; idx++) {
+      if (wrapper_instance_extensions.extensions[idx])
+         continue;
+
+      if (!instance->vk.enabled_extensions.extensions[idx])
+         continue;
+
+      wrapper_enable_extensions[wrapper_enable_extension_count++] =
+         vk_instance_extensions[idx].extensionName;
+   }
+
+   set_wrapper_required_extensions(&instance->vk,
+                                   &wrapper_enable_extension_count,
+                                   wrapper_enable_extensions);
+
+   wrapper_create_info.enabledExtensionCount = wrapper_enable_extension_count;
+   wrapper_create_info.ppEnabledExtensionNames = wrapper_enable_extensions;
+
+   result = create_instance(&wrapper_create_info, pAllocator,
+                            &instance->dispatch_handle);
+   if (result != VK_SUCCESS) {
+      vk_instance_finish(&instance->vk);
+      vk_free2(vk_default_allocator(), pAllocator, instance);
+      return vk_error(NULL, result);
+   }
+   vk_instance_dispatch_table_load(&instance->dispatch_table,
+                                   get_instance_proc_addr,
+                                   instance->dispatch_handle);
+
+   *pInstance = wrapper_instance_to_handle(instance);
+
+   return VK_SUCCESS;
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DestroyInstance(VkInstance _instance,
+                        const VkAllocationCallbacks *pAllocator)
+{
+   VK_FROM_HANDLE(wrapper_instance, instance, _instance);
+   instance->dispatch_table.DestroyInstance(instance->dispatch_handle,
+                                            pAllocator);
+   vk_instance_finish(&instance->vk);
+   vk_free2(&instance->vk.alloc, pAllocator, instance);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DebugReportMessageEXT(VkInstance _instance,
+                                VkDebugReportFlagsEXT flags,
+                                VkDebugReportObjectTypeEXT objectType,
+                                uint64_t object,
+                                size_t location,
+                                int32_t messageCode,
+                                const char* pLayerPrefix,
+                                const char* pMessage)
+{
+   VK_FROM_HANDLE(wrapper_instance, instance, _instance);
+
+   switch (objectType) {
+   case VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
+      break;
+   default:
+      object = (uint64_t)VK_NULL_HANDLE;
+   }
+
+   vk_common_DebugReportMessageEXT(instance->dispatch_handle, flags,
+                                   objectType, object, location, messageCode,
+                                   pLayerPrefix, pMessage);
+}
+
+VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+wrapper_GetInstanceProcAddr(VkInstance _instance,
+                            const char *pName)
+{
+   VK_FROM_HANDLE(wrapper_instance, instance, _instance);
+   return vk_instance_get_proc_addr(&instance->vk,
+                                    &wrapper_instance_entrypoints,
+                                    pName);
+}
+
+PUBLIC VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+vk_icdGetInstanceProcAddr(VkInstance instance,
+                          const char *pName);
+
+
+PUBLIC VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+vk_icdGetInstanceProcAddr(VkInstance instance,
+                          const char *pName)
+{
+   return wrapper_GetInstanceProcAddr(instance, pName);
+}
diff --git a/src/vulkan/wrapper/wrapper_physical_device.c b/src/vulkan/wrapper/wrapper_physical_device.c
new file mode 100644
index 00000000000..cb0e766d950
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_physical_device.c
@@ -0,0 +1,153 @@
+#include "wrapper_private.h"
+#include "wrapper_trampolines.h"
+#include "vk_alloc.h"
+#include "vk_common_entrypoints.h"
+#include "vk_dispatch_table.h"
+#include "vk_extensions.h"
+#include "vk_physical_device.h"
+#include "wsi_common.h"
+
+static VkResult
+wrapper_setup_device_extensions(struct wrapper_physical_device *pdevice) {
+   struct vk_device_extension_table *exts = &pdevice->vk.supported_extensions;
+   VkExtensionProperties pdevice_extensions[VK_DEVICE_EXTENSION_COUNT];
+   uint32_t pdevice_extension_count = VK_DEVICE_EXTENSION_COUNT;
+   VkResult result;
+
+   result = pdevice->dispatch_table.EnumerateDeviceExtensionProperties(
+      pdevice->dispatch_handle, NULL, &pdevice_extension_count, pdevice_extensions);
+
+   if (result != VK_SUCCESS)
+      return result;
+
+   *exts = wrapper_device_extensions;
+
+   for (int i = 0; i < pdevice_extension_count; i++) {
+      int idx;
+      for (idx = 0; idx < VK_DEVICE_EXTENSION_COUNT; idx++) {
+         if (strcmp(vk_device_extensions[idx].extensionName,
+                     pdevice_extensions[i].extensionName) == 0)
+            break;
+      }
+
+      if (idx >= VK_DEVICE_EXTENSION_COUNT)
+         continue;
+
+      if (wrapper_filter_extensions.extensions[idx])
+         continue;
+
+      exts->extensions[idx] = true;
+   }
+
+   exts->KHR_present_wait = exts->KHR_timeline_semaphore;
+
+   return VK_SUCCESS;
+}
+
+static VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+wrapper_wsi_proc_addr(VkPhysicalDevice physicalDevice, const char *pName)
+{
+   VK_FROM_HANDLE(vk_physical_device, pdevice, physicalDevice);
+   return vk_instance_get_proc_addr_unchecked(pdevice->instance, pName);
+}
+
+VkResult enumerate_physical_device(struct vk_instance *_instance)
+{
+   struct wrapper_instance *instance = (struct wrapper_instance *)_instance;
+   VkPhysicalDevice physical_devices[16];
+   uint32_t physical_device_count = 16;
+   VkResult result;
+
+   result = instance->dispatch_table.EnumeratePhysicalDevices(
+      instance->dispatch_handle, &physical_device_count, physical_devices);
+
+   if (result != VK_SUCCESS)
+      return result;
+
+   for (int i = 0; i < physical_device_count; i++) {
+      PFN_vkGetInstanceProcAddr get_instance_proc_addr;
+      struct wrapper_physical_device *pdevice;
+
+      pdevice = vk_zalloc(&_instance->alloc, sizeof(*pdevice), 8,
+                          VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE);
+      if (!pdevice)
+         return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+      struct vk_physical_device_dispatch_table dispatch_table;
+      vk_physical_device_dispatch_table_from_entrypoints(
+         &dispatch_table, &wrapper_physical_device_entrypoints, true);
+      vk_physical_device_dispatch_table_from_entrypoints(
+         &dispatch_table, &wsi_physical_device_entrypoints, false);
+      vk_physical_device_dispatch_table_from_entrypoints(
+         &dispatch_table, &wrapper_physical_device_trampolines, false);
+
+      result = vk_physical_device_init(&pdevice->vk,
+                                       &instance->vk,
+                                       NULL, NULL, NULL,
+                                       &dispatch_table);
+      if (result != VK_SUCCESS) {
+         vk_free(&_instance->alloc, pdevice);
+         return result;
+      }
+
+      pdevice->instance = instance;
+      pdevice->dispatch_handle = physical_devices[i];
+      get_instance_proc_addr = instance->dispatch_table.GetInstanceProcAddr;
+
+      vk_physical_device_dispatch_table_load(&pdevice->dispatch_table,
+                                             get_instance_proc_addr,
+                                             instance->dispatch_handle);
+
+      wrapper_setup_device_extensions(pdevice);
+      wrapper_setup_device_features(pdevice);
+
+      struct vk_features *supported_features = &pdevice->vk.supported_features;
+      supported_features->presentId = true;
+      supported_features->presentWait = supported_features->timelineSemaphore;
+      supported_features->swapchainMaintenance1 = true;
+      supported_features->imageCompressionControlSwapchain = false;
+
+      result = wsi_device_init(&pdevice->wsi_device,
+                               wrapper_physical_device_to_handle(pdevice),
+                               wrapper_wsi_proc_addr, &_instance->alloc, -1,
+                               NULL, &(struct wsi_device_options){});
+      if (result != VK_SUCCESS) {
+         vk_physical_device_finish(&pdevice->vk);
+         vk_free(&_instance->alloc, pdevice);
+         return result;
+      }
+      pdevice->vk.wsi_device = &pdevice->wsi_device;
+      pdevice->wsi_device.force_bgra8_unorm_first = true;
+#ifdef __TERMUX__
+      pdevice->wsi_device.wants_ahb = true;
+#endif
+
+      list_addtail(&pdevice->vk.link, &_instance->physical_devices.list);
+   }
+
+   return VK_SUCCESS;
+}
+
+void destroy_physical_device(struct vk_physical_device *pdevice) {
+   wsi_device_finish(pdevice->wsi_device, &pdevice->instance->alloc);
+   vk_physical_device_finish(pdevice);
+   vk_free(&pdevice->instance->alloc, pdevice);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice,
+                                           const char* pLayerName,
+                                           uint32_t* pPropertyCount,
+                                           VkExtensionProperties* pProperties)
+{
+   return vk_common_EnumerateDeviceExtensionProperties(physicalDevice,
+                                                       pLayerName,
+                                                       pPropertyCount,
+                                                       pProperties);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
+                                   VkPhysicalDeviceFeatures2* pFeatures) {
+   vk_common_GetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
+}
diff --git a/src/vulkan/wrapper/wrapper_private.h b/src/vulkan/wrapper/wrapper_private.h
new file mode 100644
index 00000000000..7782ef58335
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_private.h
@@ -0,0 +1,75 @@
+#include "wrapper_entrypoints.h"
+#include "vulkan/runtime/vk_instance.h"
+#include "vulkan/runtime/vk_physical_device.h"
+#include "vulkan/runtime/vk_device.h"
+#include "vulkan/runtime/vk_queue.h"
+#include "vulkan/runtime/vk_command_buffer.h"
+#include "vulkan/runtime/vk_log.h"
+#include "vulkan/util/vk_dispatch_table.h"
+#include "vulkan/wsi/wsi_common.h"
+#include <dlfcn.h>
+
+extern const struct vk_instance_extension_table wrapper_instance_extensions;
+extern const struct vk_device_extension_table wrapper_device_extensions;
+extern const struct vk_device_extension_table wrapper_filter_extensions;
+
+struct wrapper_instance {
+   struct vk_instance vk;
+
+   VkInstance dispatch_handle;
+   struct vk_instance_dispatch_table dispatch_table;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_instance, vk.base, VkInstance,
+                       VK_OBJECT_TYPE_INSTANCE)
+
+struct wrapper_physical_device {
+   struct vk_physical_device vk;
+
+   VkPhysicalDevice dispatch_handle;
+   struct wsi_device wsi_device;
+   struct wrapper_instance *instance;
+   struct vk_physical_device_dispatch_table dispatch_table;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_physical_device, vk.base, VkPhysicalDevice,
+                       VK_OBJECT_TYPE_PHYSICAL_DEVICE)
+
+struct wrapper_queue {
+   struct vk_queue vk;
+
+   struct wrapper_device *device;
+   VkQueue dispatch_handle;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_queue, vk.base, VkQueue,
+                       VK_OBJECT_TYPE_QUEUE)
+
+struct wrapper_device {
+   struct vk_device vk;
+
+   VkDevice dispatch_handle;
+   struct list_head command_buffers;
+   struct vk_device_dispatch_table dispatch_table;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_device, vk.base, VkDevice,
+                       VK_OBJECT_TYPE_DEVICE)
+
+struct wrapper_command_buffer {
+   struct vk_command_buffer vk;
+
+   struct wrapper_device *device;
+   struct list_head link;
+   VkCommandPool pool;
+   VkCommandBuffer dispatch_handle;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_command_buffer, vk.base, VkCommandBuffer,
+                       VK_OBJECT_TYPE_COMMAND_BUFFER)
+
+VkResult enumerate_physical_device(struct vk_instance *_instance);
+void destroy_physical_device(struct vk_physical_device *pdevice);
+
+void
+wrapper_setup_device_features(struct wrapper_physical_device *physical_device);
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 898bdd7bcdb..a11b6bd64bc 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -201,6 +201,8 @@ wsi_device_init(struct wsi_device *wsi,
    WSI_GET_CB(GetPhysicalDeviceFormatProperties2);
    WSI_GET_CB(GetPhysicalDeviceImageFormatProperties2);
    WSI_GET_CB(GetSemaphoreFdKHR);
+   WSI_GET_CB(ImportSemaphoreFdKHR);
+   WSI_GET_CB(ImportFenceFdKHR);
    WSI_GET_CB(ResetFences);
    WSI_GET_CB(QueueSubmit);
    WSI_GET_CB(WaitForFences);
@@ -1167,8 +1169,16 @@ wsi_signal_semaphore_for_image(struct vk_device *device,
                                const struct wsi_image *image,
                                VkSemaphore _semaphore)
 {
-   if (device->physical->supported_sync_types == NULL)
-      return VK_SUCCESS;
+   if (device->physical->supported_sync_types == NULL) {
+      const VkImportSemaphoreFdInfoKHR import_fd_info = {
+         .sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
+         .semaphore = _semaphore,
+         .handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
+         .fd = -1,
+         .flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
+      };
+      return chain->wsi->ImportSemaphoreFdKHR(chain->device, &import_fd_info);
+   }
 
    VK_FROM_HANDLE(vk_semaphore, semaphore, _semaphore);
 
@@ -1203,8 +1213,16 @@ wsi_signal_fence_for_image(struct vk_device *device,
                            const struct wsi_image *image,
                            VkFence _fence)
 {
-   if (device->physical->supported_sync_types == NULL)
-      return VK_SUCCESS;
+   if (device->physical->supported_sync_types == NULL) {
+      const VkImportFenceFdInfoKHR import_fd_info = {
+         .sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
+         .fence = _fence,
+         .handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
+         .fd = -1,
+         .flags = VK_FENCE_IMPORT_TEMPORARY_BIT,
+      };
+      return chain->wsi->ImportFenceFdKHR(chain->device, &import_fd_info);
+   }
 
    VK_FROM_HANDLE(vk_fence, fence, _fence);
 
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 014cb718b17..2316d3156d0 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -263,6 +263,8 @@ struct wsi_device {
    WSI_CB(GetPhysicalDeviceFormatProperties2);
    WSI_CB(GetPhysicalDeviceImageFormatProperties2);
    WSI_CB(GetSemaphoreFdKHR);
+   WSI_CB(ImportSemaphoreFdKHR);
+   WSI_CB(ImportFenceFdKHR);
    WSI_CB(ResetFences);
    WSI_CB(QueueSubmit);
    WSI_CB(WaitForFences);
-- 
2.47.0

